---
layout: post
title: MLOps 4 - Kubernetes란?
tags: [MLOps]
use_math: true
---

# 배경지식

> 배포 방식의 발전

![](https://user-images.githubusercontent.com/31475037/93745551-b3980100-fc2e-11ea-942c-b4c46ddb7fdb.png)

### 전통적인 배포 시대

전통적인 애플리케이션 배포는 한개의 서버에서 실행했었습니다. 한 서버에서 여러 애플리케이션 리소스 할당을 동시에 처리하기 힘들었기에 문제가 발생했습니다. 예를 들어 서버 하나에 여러 애플리케이션을 실행했을 때, 리소스 전부를 차지하는 애플리케이션이 있을 수 있고, 이로인해 다른 애플리케이션 성능이 저하되었습니다. 이에 대한 해결책으로 나온 것이, 서로 다른 여러 서버에 각 애플리케이션을 실행하는 방식이었습니다.

하지만 이러한 방식은 리소스의 활용률을 높이지 최대한 끌어내지 못했습니다.

### 가상화된 배포 시대

리소스 활용률을 최대한 올리기 위해서 여러대의 서버를 두는 것보다 한 개의 서버에 VM(Virtual Machine)을 만들어 가상화 시켰습니다. 가상화를 사용하면 VM간에 OS를 공유하지 않기에 애플리케이션을 격리 할 수 있었습니다.

그러나 VM으로 이미지를 만들어 배포를 하게 되면 하나에 700MB 크기의 수많은 애플리케이션을 배포해야합니다. 이러한 문제를 해결하기 위해 컨테이너 기술이 나왔습니다.

### 컨테이너 개발 시대

컨테이너는 가상머신과 동일한 이점을 제공하지만, 훨씬 더 가볍고 성능이 좋았습니다. 이 중 도커는 기존 VM에서 쓰던 Hypervisor 대신에 docker engine을 사용, 오버헤드를 줄였습니다.

도커를 이용해 격리된 OS 환경과 함께 컨테이너화된 애플리케이션 개발이 가능케 되었습니다. 이를 통해 애플리케이션을 기능별로 컨테이너화 시켜 확장성을 높이는 MSA(Micro Service Architecture) 개발 방법론이 확산되었습니다.

또한 컨테이너의 등장으로 애플리케이션에 일관된 환경을 제공하며, 개발자가 지속적인 배포가 가능하도록 만들어 주었고, 이로 인해 개발자가 하던 developement와 운영팀이 하던 operation이 합쳐진 **DevOps** 개발 방식이 성행하였습니다.

하지만 도커와 같은 컨테이너 기술들은 다음과 같은 문제점을 가지고 있습니다.

- 컨테이너끼리 IPC를 통한 communication 불가(완전 격리되있기에)
- auto scailing 불가능
- 분산 트래픽 처리가 어려움
- 수많은 컨테이너를 관리하기가 어려움

### Container Management Tool

위와같은 문제점들을 해결하기위해 나온것이 **container management tool**들이고, docker swarm이 처음에 나온 이후 쿠버네티스(kubernetes)가 나왔고, 이젠 쿠버네티스가 업계 de fecto(업계 표준)가 되었습니다.

다음 영상을 보면 어떤 배경에서 K8S가 나타났는가에대해 자세히 설명해줍니다.

[K8S 이해를 위한 영상](https://www.youtube.com/watch?v=rdyUAduXi48&t=575s)

<br>

# 쿠버네티스란 무엇인가?

프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인하는 작업이 필요합니다. 쿠버네티스는 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 **오픈소스 container management tool**입니다.

컨테이너 기반 애플리케이션들은 하나의 시스템으로 작동하도록 배포 및 구성하기가 어렵고 귀찮지만, 쿠버네티스를 이용하면 이를 손쉽게 해줍니다. 개발자는 시스템 관리자의 도움 없이도 쿠버네티스로 애플리케이션을 배포 할 수 있습니다. 운영팀은 쿠버네티스의 자동 복구 기능을 통해 편리하게 시스템 운영이 가능해졌습니다. 쿠버네티스는 하드웨어 인프라를 추상화 시켜, 개발자는 오로지 개발에만 집중할 수 있으며, 개발자가 운영팀을 거치지 않고 애플리케이션을 직접 배포하는 방식으로서 **NoOps** 개발 방식이 등장하였습니다. 즉, 하드웨어 인프라 관리 팀과 개발 팀이 완전히 분리되었습니다.

<br>

## 주요 기능

### 리소스 최대 활용

각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시하면, 쿠버네티스는 컨테이너를 노드에 알맞게 리소스를 잘 사용하도록 오케스트레이션 해줍니다. 이를 통해 하드웨어 리소스를 최대한으로 사용할 수 있습니다.

또한 쿠버네티스에게 애플리케이션을 실행하도록 지시하면, 애플리케이션의 리소스 요구사항에 대한 디스크립션과 각 노드에서 사용 가능한 리소스에 따라 쿠버네티스가 애플리케이션을 실행할 가장 적합한 노드를 지정해줍니다. 

### 쉬워진 배포

쿠버네티스는 모든 노드를 하나의 배포 플랫폼으로 제공하기 때문에 애플리케이션 개발자는 자체적으로 애플리케이션 배포를 할 수 있으며, 클러스터를 구성하는 서버에 관해 알 필요가 없습니다. 

### Service Discovery & Load Balancing

쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출하고 로드 밸런싱 할 수 있습니다.

### Storage Orchestration

쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 탑재할 수 있습니다.

### Self Healing

쿠버네티스는 실행에 실패한 컨테이너를 다시 시작하거나, 컨테이너를 교체할 수 있습니다. 

### Secret & Configuration Management

암호, OAuth 토큰 및  SSH 키와 같은 중요한 정보를 저장, 관리하는 기능을 제공합니다.

### Auto Scailing

쿠버네티스는 오토 스케일링 기능을 지원합니다.

### Automatic Rollbacks & Rollouts

자동화된 롤백과 롤아웃 기능을 제공합니다.

> 쿠버네티스가 아닌 것

![](https://user-images.githubusercontent.com/31475037/89846540-76b30600-dbbc-11ea-8418-d5b0bf0acd1d.png)

> 쿠버네티스 인 것

![](https://user-images.githubusercontent.com/31475037/89846538-761a6f80-dbbc-11ea-9ec8-aaaf5975077a.png)

<br>

**참고 자료**

[쿠버네티스란 무엇인가?](https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/)